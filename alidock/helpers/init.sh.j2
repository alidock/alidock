#!/bin/bash -ex

# Init script for alidock that runs inside the container. Auto-generated.

# Log into the shared directory to allow debug
exec &> >(tee "{{runDir}}/log.txt")
cd /

# Check whether we have a persistent native volume and make it usable
if [[ -d /persist ]]; then
  chmod 0700 /persist
  chown {{userId}} /persist
  mkdir -p /persist/sw
  chown {{userId}} /persist/sw
  # The MIRROR directory stays on the bind mount: pre-create it
  if [[ ! -d /persist/sw/MIRROR ]]; then
    # If for some reason it is already there as a directory, leave it be
    mkdir -p "{{sharedDir}}/.sw/MIRROR"
    chown {{userId}} "{{sharedDir}}/.sw/MIRROR"
    ln -nfs "{{sharedDir}}/.sw/MIRROR" /persist/sw/MIRROR
  fi
fi

# Make directory for holding Git secrets (no sockets in Docker bind mounts)
mkdir -p /var/git-creds-{{userId}}
chmod 0700 /var/git-creds-{{userId}}
chown {{userId}} /var/git-creds-{{userId}}

# System-wide settings (prompt, etc.)
cat > /etc/profile.d/alidock.sh <<\EOF
#!/bin/bash
[[ $_ALIDOCK_ENV ]] && return 0;

function _alidock_ps1() {
  local RV=$?
  [[ $RV != 0 ]] && echo -n "$RV|"
}
export -f _alidock_ps1

function aliBuildUpdateMirrors() {(
  for REPO in $ALIBUILD_WORK_DIR/MIRROR/*/objects; do
    [[ -d $REPO ]] || continue
    REPO=$(dirname "$REPO")
    echo "Updating $(basename $REPO)"
    pushd "$REPO" &> /dev/null
      git remote update
    popd &> /dev/null
  done
)}
export -f aliBuildUpdateMirrors

export PS1='`_alidock_ps1`[{{dockName}}] \w \$> '
[[ -d /persist ]] && export ALIBUILD_WORK_DIR="/persist/sw" || export ALIBUILD_WORK_DIR="$HOME/.sw"
type alienv &> /dev/null && eval "$(alienv shell-helper)"

export GIT_PAGER=cat
type nano &> /dev/null && export GIT_EDITOR=nano

if [[ $(id -u) == {{userId}} ]]; then
  git config --global credential.helper 'cache --timeout 86400 --socket /var/git-creds-{{userId}}/socket'
  git config --global color.ui auto
fi
type hub &> /dev/null && alias git=hub
export _ALIDOCK_ENV=1

[[ $DISPLAY ]] || export DISPLAY=':0'  # web X11
EOF

# Git global options
git config --system core.pager ''
git config --system color.ui auto

# Make tab completions case insensitive
echo 'set completion-ignore-case on' >> /etc/inputrc

# Create server's SSH key
rm -f /etc/ssh/ssh_host_*_key
ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ''

# Create a user with the same name/UID as the user outside the container
useradd -d "{{sharedDir}}" -M -N -s /bin/bash -u "{{userId}}" "{{userName}}"
chmod 0755 "{{sharedDir}}"
chown "{{userName}}" "{{sharedDir}}"

# Create groups
{%- for groupName,groupId in addGroups.items() -%}
{%- if groupId is not none %}
if getent group "{{groupName}}" &> /dev/null; then
  groupmod -g "{{groupId}}" "{{groupName}}"
else
  groupadd -g "{{groupId}}" "{{groupName}}"
fi
{%- else %}
groupadd "{{groupName}}" || true
{%- endif %}
{%- endfor %}

# Add user to the list of created groups
usermod -aG "{{ addGroups.keys()|join(",") }}" "{{userName}}"

# Create a SSH key for that user and authorize it
rm -rf "{{runDir}}/ssh"
mkdir -p "{{runDir}}/ssh"
mkdir "/var/ssh-keys-{{userName}}"
pushd "{{runDir}}/ssh"
  ssh-keygen -t rsa -f alidock.pem -N ''
  mv alidock.pem.pub alidock.pub
  # authorized_keys outside shared dir to prevent wrong perms on Windows
  cp -v alidock.pub "/var/ssh-keys-{{userName}}/authorized_keys"
popd
chmod -R u=rwX,g=rX,o=rX "{{runDir}}/ssh" "/var/ssh-keys-{{userName}}"
chmod -R 0600 "{{runDir}}/ssh/alidock.pem"
chown -R "{{userName}}" "{{runDir}}/ssh" "/var/ssh-keys-{{userName}}"

# Silence login messages ("Last login:...")
touch "{{sharedDir}}/.hushlogin"
chown "{{userName}}" "{{sharedDir}}/.hushlogin"

# Create skeleton .bashrc/.bash_profile
pushd "{{sharedDir}}"
  [[ -f .bashrc ]] || cat > .bashrc <<\EOF
source /etc/bashrc
# Add your modifications below
EOF
  [[ -f .bash_profile ]] || cat > .bash_profile <<\EOF
[[ -f ~/.bashrc ]] && source ~/.bashrc
# Add your modifications below
EOF
  chown "{{userName}}" .bashrc .bash_profile
popd

# Check if we can resolve domain names; if we can't we start cloudflared
ERR=0
timeout -s9 8 getent hosts www.google.com &> /dev/null || ERR=$?
if [[ $ERR != 0 ]]; then
  nohup cloudflared proxy-dns &> /dev/null &
  printf '# Use cloudflared\nnameserver 127.0.0.1\n' > /etc/resolv.conf
fi

{% if useWebX11 -%}
# Start xpra
if [[ ! -s /etc/machine-id ]]; then
  dbus-uuidgen > /etc/machine-id
fi
su "{{userName}}" -c 'xpra start --bind-tcp=0.0.0.0:14500 --html=on --log-file={{runDir}}/xpra.log --daemon=yes --bandwidth-limit=0 --bandwidth-detection=False --start=xterm'
{%- else -%}
# Not starting xpra
{%- endif %}

# Prepare sshd config
cat > /etc/ssh/sshd_config <<\EOF
# Automatically generated by alidock
HostKey /etc/ssh/ssh_host_rsa_key
AuthorizedKeysFile /var/ssh-keys-%u/authorized_keys
PermitEmptyPasswords no
PasswordAuthentication no
ChallengeResponseAuthentication no
GSSAPIAuthentication no
GSSAPICleanupCredentials no
UsePAM yes
AllowAgentForwarding no
AllowTcpForwarding no
X11Forwarding {{ "no" if useWebX11 else "yes" }}
X11UseLocalhost no
Compression no
UseDNS no
PermitTunnel no
AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE
AcceptEnv XMODIFIERS
LogLevel INFO
EOF

# Start the SSH server
SSH_LOG=("-E" "{{runDir}}/log.txt")
sshd -V 2>&1 | grep -q -- -E || SSH_LOG=()
exec /usr/sbin/sshd -D "${SSH_LOG[@]}"
